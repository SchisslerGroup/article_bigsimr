# The \pkg{Bigsimr} package {short-title="Bigsimr-pkg" #package}


```{r ch030-basic-example-setup, cache=FALSE}
box::use(
  patchwork[...],
  dplyr[...],
  ggplot2[...],
  tidyr[drop_na],
  bigsimr[bigsimr_setup, distributions_setup],
  JuliaCall[julia_call]
)

Sys.setenv(JULIA_NUM_THREADS = parallel::detectCores())
bs <- bigsimr_setup(pkg_check = FALSE)
dist <- distributions_setup()
```

This section describes a bivariate random vector simulation workflow via the `bigsimr` `R` package. This `R` package provides an interface to the native code written in Julia (registered as the `Bigsimr` Julia package). In addition to the native Julia `Bigsimr` package and `R` interface `bigsimr`, we also provide a Python interface `bigsimr` that interfaces with the Julia `Bigsimr` package. The Julia package provides a high-performance implementation of our proposed random vector generation algorithm and associated functions (see Section \@ref(algorithms)).

The subsections below describe the basic use of `bigsimr` R package by stepping through an example workflow using the data set `airquality` that contains daily air quality measurements in New York, May to September 1973 [@Chambers1983]. This workflow proceeds from setting up the computing environment, to data wrangling, estimation, simulation configuration, random vector generation, and, finally, result visualization.

## Bivariate example

We illustrate the use of `bigsimr` using the New York air quality data set (`airquality`) included in the R `datasets` package. First, we load the `bigsimr` library and a few other convenient data science packages, including the syntactically-elegant `tidyverse` suite of `R` packages. The code chunk below prepares the computing environment:

```{r ch030-computeEnvironmentSetup, eval=FALSE, echo=TRUE}
library("tidyverse")
library("bigsimr")
# Activate multithreading in Julia
Sys.setenv(JULIA_NUM_THREADS = parallel::detectCores())
# Load the Bigsimr and Distributions Julia packages
bs <- bigsimr_setup()
dist <- distributions_setup()
```

Here, we describe a minimal working example --- a bivariate simulation of two airquality variables: `Temperature`, in degrees Fahrenheit, and `Ozone` level, in parts per billion.

```{r ch030-air-quality-data, echo=TRUE}
df <- airquality %>% select(Temp, Ozone) %>% drop_na()
glimpse(df)
```

Figure \@ref(fig:ch030-aq-joint-dist) visualizes the bivariate relationship between `Ozone` and `Temperature`. We aim to simulate random two-component vectors mimicking this structure. The margins are not normally distributed; `Ozone` level exhibits a strong positive skew.


```{r ch030-aq-joint-dist, cache=FALSE, fig.width= 8, fig.cap="Bivariate scatterplot of Ozone versus Temp with estimated marginal densities. The Ozone data are modeled marginally as log-normal and the Temperature data as normal."}
p0 <- ggplot(df, aes(Temp, Ozone)) +
  geom_point(size = 1) +
  theme(legend.position = "none") + 
  labs(x = "Temperature")

pTemp <- ggplot(df, aes(Temp)) + 
  geom_density() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

pOzone <- ggplot(df, aes(Ozone)) + 
    geom_density() +
  theme(axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank()) +
  coord_flip()

pTemp + plot_spacer() + p0 + pOzone + 
  plot_layout(widths = c(3,1), heights = c(1, 3)) 
```


Next, we specify the marginal distributions and correlation coefficient (both type and magnitude). Here the analyst is free to be creative. For this example, we avoid goodness-of-fit considerations to determine the marginal distributions. It is sensible without domain knowledge to estimate these quantities from the data, and `bigsimr` contains fast functions designed for this task.


## Specifying marginal distributions 

Based on the estimated densities in Figure \@ref(fig:ch030-aq-joint-dist), we assume `Temp` is normally distributed and `Ozone` is log-normally distributed, as the latter values are positive and skewed. We use the classical unbiased estimators for the normal distribution's parameters and maximum likelihood estimators for the log-normal parameters:


```{r ch030-aq-temp-pars, echo=TRUE}
df %>% select(Temp) %>% 
  summarise_all(.funs = c(mean = mean, sd = sd))
```


```{r ch030-aq-ozone-pars, echo=TRUE}
mle_mean <- function(x) mean(log(x))
mle_sd <- function(x) mean( sqrt( (log(x) - mean(log(x)))^2 ) )
df %>% 
  select(Ozone) %>% 
  summarise_all(.funs = c(meanlog = mle_mean, sdlog = mle_sd))
```


Now, we configure the input marginals for later input into `rvec`. The marginal distributions are specified using `Julia`'s `Distributions` package and stored in a vector.


```{r ch030-margins-alist, echo=TRUE}
margins <- c(dist$Normal(mean(df$Temp), sd(df$Temp)),
             dist$LogNormal(mle_mean(df$Ozone), mle_sd(df$Ozone)))
```


## Specifying correlation

The user must decide how to describe correlation based on the particulars of the problem. For non-normal data in our scheme, we advocate the use of Spearman's $\rho$ correlation matrix $R_S$ or Kendall's $\tau$ correlation matrix $R_K$. We also support Pearson correlation coefficient matching, while cautioning the user to check the performance for the distribution at hand (see [Monte Carlo evaluations](#simulations) below for evaluation strategies and guidance). Note that these estimation methods are classical approaches, not specifically designed for high-dimensional correlation estimation.

```{r ch030-aq-cor, echo=TRUE}
(R_S <- bs$cor(as.matrix(df), bs$Spearman))
```

## Checking target correlation matrix admissibility

Once a target correlation matrix is specified, first convert the dependency type to Pearson to correctly specify the MVN inputs. Then, check that the converted matrix $R_X$ is a valid correlation matrix (PD and 1s on the diagonal). For this bivariate example, $R_X$ is a valid correlation matrix. Note that typically in HD the resultant MVN Pearson correlation matrix is indefinite and requires approximation (see the HD examples in subsequent sections).

```{r ch030-cor-convert, echo=TRUE}
# Step 1. Mapping
(R_X <- bs$cor_convert(R_S, bs$Spearman, bs$Pearson))
```

```{r ch030-cor-check, echo=TRUE}
# Step 2. Check admissibility
bs$iscorrelation(R_X)
```

Despite being a valid correlation matrix under this definition, marginal distributions induce Frechet bounds on the possible Pearson correlation values. To check that the converted correlation values fall within these bounds, use `bigsimr::cor_bounds` to estimate the pairwise lower and upper correlation bounds. `cor_bounds` uses the Generate, Sort, and Correlate algorithm of @DH2011. For the assumed marginals, the Pearson correlation coefficient is not free to vary in [-1,1], as seen below. Our MC estimate of the bounds slightly underestimates the theoretic bounds of $(-0.881, 0.881)$. (See an analytic derivation presented in the Appendix). Since our single Pearson correlation coefficient is within the theoretical bounds, the correlation matrix is valid for our simulation strategy.

```{r ch030-cor-bounds-pearson, echo=TRUE}
bs$cor_bounds(margins[1], margins[2], bs$Pearson, n_samples = 1e6)
```

## Simulating random vectors

Finally, we execute `rvec` to simulate the desired $10,000$ random vectors from the assumed bivariate distribution of `Ozone` and `Temp`. Note that the target input in specified using the pre-computed MVN correlation matrix. Figure \@ref(fig:ch030-plot-sim) plots the 10,000 simulated points.

```{r ch030-sim-margins, echo=TRUE}
x <- bs$rvec(10000, R_X, margins)
df_sim <- as.data.frame(x)
colnames(df_sim) <- colnames(df)
```

```{r ch030-plot-sim, fig.cap="Contour plot and marginal densities for the simulated bivariate distribution of Air Quality Temperatures and Ozone levels. The simulated points mimic the observed data with respect to both the marginal characteristics and bivariate association."}
p1 <- df_sim %>%
  ggplot(aes(Temp, Ozone)) +
  geom_density_2d_filled() +
  theme(legend.position = "none") +
  labs(x = "Simulated Temperature", y = "Simulated Ozone") +
  scale_y_continuous(limits = c(0, max(df$Ozone))) +
  scale_x_continuous(limits = range(df$Temp))

p1Temp <- ggplot(df_sim, aes(Temp)) + 
  geom_density(alpha = 0.5, fill = "lightseagreen") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

p1Ozone <- ggplot(df_sim, aes(Ozone)) + 
  geom_density(alpha = 0.5, fill = "lightseagreen") + 
  theme(axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank()) +
  coord_flip() 

p1Temp + plot_spacer() + p1 + p1Ozone + 
  plot_layout(widths = c(3,1), heights = c(1, 3))
```

\clearpage
