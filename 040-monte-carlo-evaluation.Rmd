# Monte Carlo evaluations {#simulations}

```{r ch040-LoadLib040, echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE, results = "hide"}
## devtools::install_github("SchisslerGroup/bigsimr", ref = 'develop')
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
# reticulate::use_condaenv("bigsimr")
library(bigsimr)
library(tidyverse)
cores <- as.integer( parallel::detectCores() - 1 )
## cores <- as.integer( 1 )
set.seed(10162020)
```

```{r ch040-preview, echo = FALSE, eval = FALSE}
bookdown::preview_chapter('040-monte-carlo-evaluation.Rmd')
```

Before applying our methodology to real data simulation, we conduct several Monte Carlo studies to investigate method performance.
Since marginal parameter matching in our scheme is essentially a sequence of univariate inverse probability transforms, the challenging aspects are the accuracy of dependency matching and computational efficiency.
And, so, we'll focus the numerical experiments on assessing how well the procedure scales to high dimension with respect to reasonable computation times (property S1 above) and accurately m
atching marginal and dependency parameters. 

Further, we select simulaiton configurations to ultimately simulate discrete-valued RNA-seq data and the simulations will proceed in increasing complexity, leading to our motivating application in Section \@ref(examples). 
We begin wiith empirically evaluating the dependency matching across all three supported correlations --- Pearson's, Spearman's, and Kendall's ---- in identical, bivariate marginal configurations.
The simulations progress from bivariate normal, to bivariate gamma (non-normal yet continuous), and bivariate negative binomial (mimicking RNA-seq counts).

## Bivariate experiments

```{r ch040-biNormal, echo = FALSE, eval = TRUE}
mu <- 0
sigma <- 1
if ( !file.exists( 'results/biNorm_sims.rds' ) )  {
    mom_norm <- function(x) {
        m <- mean(x)
        s <- sd(x)
        list(mean = m, sd = s)
    }
    mu <- 0
    sigma <- 1
    margins <- alist(
        qnorm(mean = mu, sd = sigma),
        qnorm(mean = mu, sd = sigma)
    )
    type <- c("pearson", "spearman", "kendall")
    cores <- as.integer( parallel::detectCores() - 1 )
    n <- c(1e3, 1e4, 1e5)
    ## n <- c(1e1, 1e2, 1e3)
    adjustForDiscrete <- c(FALSE)
    eps <- 1e-2
    grid_steps <- 100
    ## grid_steps <- 10
    sim_pars <- expand.grid(type = type, cores = cores, n = n,
                            stringsAsFactors = FALSE,
                            adjustForDiscrete = adjustForDiscrete)
    res <- data.frame()
    dir.create("./results/biNorm_sims", showWarnings = TRUE, recursive = TRUE)
    for (i in 1:nrow(sim_pars)) {
        type <- sim_pars$type[i]
        cores <- sim_pars$cores[i]
        n <- sim_pars$n[i]
        adjustForDiscrete <- sim_pars$adjustForDiscrete[i]
        tmp_bounds <- cor_bounds(margins, type = type)
        cor_lo <- tmp_bounds$lower[1,2] + eps
        cor_hi <- tmp_bounds$upper[1,2] - eps
        cor_seq <- seq(cor_lo, cor_hi, length.out = grid_steps)
        ## rho = cor_seq[1]
        for (rho in cor_seq) {
            Rho <- matrix(rho, 2, 2)
            diag(Rho) <- 1.0
            ## Rho <- convertCor( rho = Rho, from = type, to = 'pearson' )
            time_data <- system.time({
                ## x <- rmvn(n = n, mu = rep( mu, 2 ), sigma = Rho)
                ## use rvec to test our software
                x <- rvec(n = n,
                          rho = Rho,
                          margins = margins,
                          type = type,
                          cores = cores)
            })
            ## Save the sims in case
            id <- paste0(
                "d", 2,
                "-N", n,
                "-c", cores,
                "-r", rho,
                "-Cor", type,
                "-adj", as.character(adjustForDiscrete),
                "-dev", "1CORE",
                "-lib", "bigsimr"
            )
            ## save sims in their own subdirectory
            saveRDS(x, file = paste0("./results/biNorm_sims/", id, ".rds"))
            ## Estimate statistics
            Rho_hat <- cor_fast(x, method = type)
            rho_hat <- Rho_hat[1, 2]
            norm_args_hat <- mom_norm(x[,1])
            mu_hat <- norm_args_hat$mean
            sigma_hat <- norm_args_hat$sd
            ## Save the results
            res <- rbind(res, data.frame(
                                  method = "bigsimr",
                                  device = "CPU",
                                  type = type,
                                  cores = cores,
                                  margins = "norm",
                                  adjustForDiscrete = adjustForDiscrete,
                                  d = 2,
                                  N = n,
                                  rho = rho,
                                  rho_hat = rho_hat,
                                  mean = mu,
                                  sd = sigma,
                                  mean_hat = mu_hat,
                                  sd_hat = sigma_hat,
                                  sim_time = unname(time_data["elapsed"])
                              ))
        }
    }
    res$type <- factor(res$type, levels = c("pearson",  "spearman", "kendall" ) )
    saveRDS(object = res, "./results/biNorm_sims.rds")
}
```

*Bivariate Normal*.
Let's simulate a bivariate normal and check our correlation matching performance as N increases.
Standard bivariate normal 
Here we have BVN( $\mu_1 = \mu_2 = 0, \rho_{type}$ ).
We vary $\rho$ across the entire possible range of correlations for each correlation type.
Figure \@ref(fig:ch040-biNormPlot) `bigsimr` recovers the Pearson specified correlations for MVN.

```{r ch040-biNormPlot, echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE, fig.height = 5, fig.width= 8, fig.align='center', fig.cap = "`bigsimr` recovers the Pearson specified correlations for MVN."}
dat <- readRDS("./results/biNorm_sims.rds")
dat %>%
    filter(cores == cores) %>%
    ggplot(aes(rho, rho_hat, color = type)) +
    ## ggplot(aes(rho, rho_hat)) +
    geom_point() +
    geom_abline(slope = 1) +
    ## facet_wrap(~ + N) + theme_bw()
    facet_wrap(~ type + N) + theme_bw()
## ggsave('fig/plot-biNormPlot.pdf')
```

```{r ch040-biGamma, echo = FALSE, eval = TRUE}
shape <- 10
rate <- 1
if ( !file.exists( 'results/biGamma_sims.rds' ) )  {
    mom_gamma <- function(x) {
        m <- mean(x)
        s <- sd(x)
        list(shape = m^2 / s^2, rate = m / s^2)
    }
    margins <- alist(
        qgamma(shape = shape, rate = rate),
        qgamma(shape = shape, rate = rate)
    )

    type <- c("pearson", "spearman", "kendall")
    ## cores <- c(1L)
    cores <- as.integer( parallel::detectCores() - 1 )
    n <- c(1e3, 1e4, 1e5)
    ## n <- c(1e1, 1e2, 1e3)
    adjustForDiscrete <- c(FALSE)

    eps <- 1e-2
    grid_steps <- 100
    ## grid_steps <- 10
    sim_pars <- expand.grid(type = type, cores = cores, n = n,
                            stringsAsFactors = FALSE,
                            adjustForDiscrete = adjustForDiscrete)


    dir.create("./results/biGamma_sims", showWarnings = TRUE, recursive = TRUE)
    res <- data.frame()
    for (i in 1:nrow(sim_pars)) {
        
        type <- sim_pars$type[i]
        cores <- sim_pars$cores[i]
        n <- sim_pars$n[i]
        adjustForDiscrete <- sim_pars$adjustForDiscrete[i]

        tmp_bounds <- cor_bounds(margins, type = type)
        cor_lo <- tmp_bounds$lower[1,2] + eps
        cor_hi <- tmp_bounds$upper[1,2] - eps
        cor_seq <- seq(cor_lo, cor_hi, length.out = grid_steps)

        ## rho = cor_seq[1]
        for (rho in cor_seq) {
            Rho <- matrix(rho, 2, 2)
            diag(Rho) <- 1.0

            time_data <- system.time({
                x <- rvec(n = n,
                          rho = Rho,
                          margins = margins,
                          cores = cores,
                          type = type,
                          ensure_PSD = TRUE)
            })

            ## Save the sims in case
            id <- paste0(
                "d", 2,
                "-N", n,
                "-c", cores,
                "-r", rho,
                "-Cor", type,
                "-adj", as.character(adjustForDiscrete),
                "-dev", "CPU",
                "-lib", "bigsimr"
            )
            saveRDS(x, file = paste0("./results/biGamma_sims/", id, ".rds"))

            ## Estimate statistics
            Rho_hat <- cor_fast(x, method = type)
            rho_hat <- Rho_hat[1, 2]
            gamma_args_hat <- mom_gamma(x[,1])
            shape_hat <- gamma_args_hat$shape
            rate_hat <- gamma_args_hat$rate

            ## Save the results
            res <- rbind(res, data.frame(
                                  method = "bigsimr",
                                  device = "CPU",
                                  type = type,
                                  cores = cores,
                                  margins = "gamma",
                                  adjustForDiscrete = adjustForDiscrete,
                                  d = 2,
                                  N = n,
                                  rho = rho,
                                  rho_hat = rho_hat,
                                  shape = shape,
                                  rate = rate,
                                  shape_hat = shape_hat,
                                  rate_hat = rate_hat,
                                  sim_time = unname(time_data["elapsed"])
                              ))
        }
    }
    res$type <- factor(res$type, levels = c("pearson",  "spearman", "kendall" ) )
    saveRDS(object = res, "./results/biGamma_sims.rds")
}
```

*Bivariate Gamma*. 
Similarly, let's check the performance for a non-symmetric continuous distribution: a standard (rate =1) bivariate gamma.
Here we have a Bivariate Gamma with $shape_1 = shape_2 = 10, \rho_{type}$.
We vary $\rho$ across the entire possible range of correlations for each correlation type.
Figure \@ref(fig:ch040-biGammaPlot) `bigsimr` recovers the Pearson specified correlations for bivariate gamma.

```{r ch040-biGammaPlot, echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE, fig.height = 5, fig.width= 8, fig.align='center', fig.cap = "`bigsimr` recovers the Pearson specified correlations for Bivariate Gamma."}
dat <- readRDS("./results/biGamma_sims.rds")
dat %>%
    filter(cores == cores) %>%
    ggplot(aes(rho, rho_hat, color = type)) +
    ## ggplot(aes(rho, rho_hat)) +
    geom_point() +
    geom_abline(slope = 1) +
    ## facet_wrap(~ + N) + theme_bw()
    facet_wrap(~ type + N) + theme_bw()
## ggsave('fig/plot-biGammaPlot.pdf')
```

```{r ch040-biNegBin, echo = FALSE, eval = TRUE}
size <- 4
prob <- 3e-04
if ( !file.exists( 'results/biNB_sims.rds' ) )  {
    mom_nbinom <- function(x) {
        m <- mean(x)
        s <- sd(x)
        list(size = m^2 / (s^2 - m), prob = m / s^2)
    }

    margins <- alist(
        qnbinom(size = size, prob = prob),
        qnbinom(size = size, prob = prob)
    )

    type <- c("pearson", "spearman", "kendall")
    cores <- as.integer( parallel::detectCores() - 1 )
    ## cores <- cores
    n <- c(1e3, 1e4, 1e5)
    ## n <- c(1e1, 1e2, 1e3)
    adjustForDiscrete <- c(FALSE)

    eps <- 1e-2
    grid_steps <- 100
    ## grid_steps <- 10
    sim_pars <- expand.grid(type = type, cores = cores, n = n,
                            stringsAsFactors = FALSE,
                            adjustForDiscrete = adjustForDiscrete)

    dir.create("./results/biNB_sims", showWarnings = TRUE, recursive = TRUE)
    res <- data.frame()
    for (i in 1:nrow(sim_pars)) {
        type <- sim_pars$type[i]
        cores <- sim_pars$cores[i]
        n <- sim_pars$n[i]
        adjustForDiscrete <- sim_pars$adjustForDiscrete[i]
        ## AGS. 17 Oct 2020. cor_bounds failed.
        ## I'll create a minimal working example and open an issue
        ## tmp_bounds <- cor_bounds(margins, type = type)
        ## cor_lo <- tmp_bounds$lower[1,2] + eps
        ## cor_hi <- tmp_bounds$upper[1,2] - eps
        cor_lo <- -0.75
        cor_hi <- 0.95
        cor_seq <- seq(cor_lo, cor_hi, length.out = grid_steps)

        for (rho in cor_seq) {
            Rho <- matrix(rho, 2, 2)
            diag(Rho) <- 1.0

            time_data <- system.time({
                x <- rvec(n = n,
                          rho = Rho,
                          margins = margins,
                          cores = cores,
                          type = type,
                          ensure_PSD = TRUE)
            })

            ## Save the sims in case
            id <- paste0(
                "d", 2,
                "-N", n,
                "-c", cores,
                "-r", rho,
                "-Cor", type,
                "-adj", as.character(adjustForDiscrete),
                "-dev", "CPU",
                "-lib", "bigsimr"
            )
            saveRDS(x, file = paste0("./results/biNB_sims/", id, ".rds"))

            ## Estimate statistics
            Rho_hat <- cor_fast(x, method = type)
            rho_hat <- Rho_hat[1, 2]
            nbinom_args_hat <- mom_nbinom(x[,1])
            size_hat <- nbinom_args_hat$size
            prob_hat <- nbinom_args_hat$prob

            ## Save the results
            res <- rbind(res, data.frame(
                                  method = "bigsimr",
                                  device = "CPU",
                                  type = type,
                                  cores = cores,
                                  margins = "nbinom",
                                  adjustForDiscrete = adjustForDiscrete,
                                  d = 2,
                                  N = n,
                                  rho = rho,
                                  rho_hat = rho_hat,
                                  size = size,
                                  prob = prob,
                                  size_hat = size_hat,
                                  prob_hat = prob_hat,
                                  sim_time = unname(time_data["elapsed"])
                              ))
        }
    }
    res$type <- factor(res$type, levels = c("pearson",  "spearman", "kendall" ) )
    saveRDS(object = res, "./results/biNB_sims.rds")
}
```

*Bivariate Negative Binomial*. 
Let's check the performance for a discrete distribution: a bivariate negative binomial.
We use values that are motivated by our RNA-seq data, namely the mean probability and sizes estimated from the data ( see [Example applications for our motivating data](examples) for estimation details): Bivariate Negative Binomial ( $prob_1 = prob_2 = `r prob`, size_1 = size_2 = 4,\rho_{type}$ ).
We vary $\rho$ across the entire possible range of correlations for each correlation type.
Figure \@ref(fig:ch040-biNegBinPlot) `bigsimr` recovers the Pearson specified correlations for bivariate negative binomial.

```{r ch040-biNegBinPlot, echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE, fig.path='fig/plot-', dev='png', fig.ext='png', fig.align='center', fig.width = 8, fig.height=5,fig.cap = "`bigsimr` recovers the correlations for bivariate negative binomial only approximately for Pearson but (nearly) exactly for the rank-based correlations."}
dat <- readRDS("./results/biNB_sims.rds")
dat %>%
    filter(cores == cores) %>%
    ggplot(aes(rho, rho_hat, color = type)) +
    ## ggplot(aes(rho, rho_hat)) +
    geom_point() +
    geom_abline(slope = 1) +
    ## facet_wrap(~ + N) + theme_bw()
    facet_wrap(~ type + N) + theme_bw()
## ggsave('fig/plot-biNegBinPlot.pdf')
```

Taken together, the studies show our methology are accuracy across the entire range of possible correlation values for the rank-based dependency measures in continuous marginals.
For the two non-normal bivariate marginals, the Pearson correlation matching is approximate.
Table XX contains the average absolute error (MAE) in reproducing the desired dependency measures for the three bivariate scenarios.
For discrete margins, matching the dependency measures was somewhat less accurate, even for the rank-based metrics, especially near the correlation bounds.
Since the bivariate normal exactly matches all dependency measures in our scheme, we also report relative MSE of the non-normal cases to the normal simulations.

```{r ch040-biMSEtable}
## compare relative differences in MSE for each dependency, compared to Pearson
allDat <- NULL
dat <- readRDS("./results/biNorm_sims.rds") %>% select( margins, type, N, rho, rho_hat  ) 
allDat <- rbind( allDat, dat )
dat <- readRDS("./results/biGamma_sims.rds") %>% select( margins, type, N, rho, rho_hat  )
allDat <- rbind( allDat, dat )
dat <- readRDS("./results/biNB_sims.rds") %>% select( margins, type, N, rho, rho_hat  )
allDat <- rbind( allDat, dat )
allDat$margins <- factor(allDat$margins, levels = c( 'norm', 'gamma', 'nbinom') )
allDat$type <- factor(allDat$type, levels = c( 'kendall', 'spearman', 'pearson' ) )
allDat$N <- factor(allDat$N, levels = c( 1000, 10000, 100000) )
## tabMSE  <- allDat %>%
##    group_by( N, margins ) %>%
##    summarize( mse = mean( ( rho - rho_hat )^2 ) )
tabMSE  <- allDat %>%
    ## filter( N == 100000) %>%
    group_by( N, type, margins ) %>%
##     summarize( mse = mean( ( rho - rho_hat )^2 ) ) %>%
    summarize( mae = mean( abs( rho - rho_hat )  ) )
## normMSE <- as.numeric( tabMSE[ tabMSE$margins == 'norm', 'mse' ] ) 
## ( tabMSE$mse - normMSE ) / normMSE
## ( tabMSE$mse - as.numeric( tabMSE[ tabMSE$margins == 'norm', 'mse' ]) )
## ( tabMSE$mse - as.numeric( tabMSE[ tabMSE$margins == 'norm', 'mse' ]) ) / tabMSE$mse
knitr::kable(
  tabMSE, booktabs = TRUE,
  caption = 'Average abolute error in matching the target dependency and  '
)
```

Generally, the accuracy seems adequate for most applications, at least in these limited simulation settings.
Of course, one could choose marginals that lead to poor matching by construction.
In partice, we recommend users to always evaluate the accuracy for their application, using methods similar to those presented above.
See [Discusion](discussion) for future directions for fast Pearson matching and discrete-specific modifications.

## Scale up to Ultra-High Dimensions

With some assurance of the method's accuracy from the low-dimensional perspective in the bivariate setting, we now turn to assessing whether the `bigsimr` can scale to large dimesional problems. 
Now we seek evidence to determine whether the method can scale to higher dimensions in a practical time.
Using our motivating RNA-seq data, described in [Background](background), we filtered the orignal 20,501 genes to the high-expressing genes at increasing percentiles, $1, 5, 10, 15, 20, 25\%$, to obtain $d=\{206, 1026, 2051, 3076, 4101, 5127\}$ marginals and $\binom{d}{2}$ pairwise correlations at each setting.
For example, for $d=5127$ there are $13,140,501$ correlation coefficients.
We estimated the marginal negative binomial parameters and the correlation coefficients from the RNA-seq data to seed our simulations.
( See [Example applications for our motivating data](examples) for a detailed descrition of estimation).
Figure \@ref(fig:ch040-gpuVScpuFig) displays computation times using various high-performance settings to produce $B=10,000$ random vectors.
The Pearson simulations are much faster since the correlation conversion steps are avoided (pre-processing step; see [Algorithms](algorithms)), but as we known from above the accuracy will suffer slightly, especially near the negative boundary of the possible correlations.
Matching Spearman's correlation at larger $d$ gets costly if one wants to produce $B=10,000$ random vectors at many different simulation settings.
We recommend computing this type of simulations on a computing cluster (possibly using `rslurm`; see the [Advance Use](advanced-use)).

```{r ch040-gpuVScpuFig, echo=F, out.width='80%', fig.align='center', fig.cap="Computation times as d increases. We filter to the top 1, 5, 10, 15, 20, 25\\% expressing genes (in terms of median expression.)"}
knitr::include_graphics("fig/cpu-gpu-times.png")
```
